import numpy as np
import scipy
import scipy.stats
import panm_globals
import logging
import os.path
from collections import deque


class VehicleGenerator(object, panm_globals.MatfileSOKPReader):

    def __init__(self, file_name):
        _, ext = os.path.splitext(file_name)
        ext = ext.lower()
        file_name = os.path.join('vehiclegen', file_name)
        if ext == '.mat':
            self.read_mat(file_name)
        else:
            raise TypeError('unsupported input file type `{:s}`'.format(file_name))
        # The vehicle generator uses its own random generator state, hence the sequence of random values generated by
        # this class is identical regardless of other random processes used by the simulation software.
        self.random_state = np.random.RandomState(27601)
        # Initialize the random generator with lambda equal to one. We will generate the requested number of samples
        # at the beginning of each time slot and scale the headways according to the number of vehicles in the slot.
        self.headway_rv = scipy.stats.expon()
        self.slot_start_time = 0.0
        self.slot_vehicles = deque()
        self.slot_idx = 0

    def generate_next_vehicle(self, last_vehicle_entrance_time):
        # Did we generate all vehicles for this input slot?
        if len(self.slot_vehicles) == 0:
            # Yes, the vehicle queue is empty. We have to generate the queue for the next slot and return back the
            # first headway.
            while True:
                # If we are at the end of inputs ...
                if self.slot_idx >= len(self.data):
                    # ... generate just a single headway that is equal to infinity
                    self.slot_vehicles = deque([np.inf])
                    break
                # If there are still some input slots to process, do so.
                num_vehicles_in_slot = self.data[self.slot_idx]
                self.slot_idx += 1
                self.slot_start_time += self.time_step
                if num_vehicles_in_slot > 0:
                    # Generate all headways and accumulate them
                    headways = self.headway_rv.rvs(size=num_vehicles_in_slot, random_state=self.random_state)
                    headways = headways.cumsum()
                    # The last sample will be forgotten, it serves only to provide the time gap at the end of the slot
                    gap_to_end = self.headway_rv.rvs(random_state=self.random_state)
                    slot_total_time = headways[-1] + gap_to_end
                    slot_scale = self.time_step / slot_total_time
                    headways = self.slot_start_time - self.time_step + slot_scale * headways
                    # Convert the numpy ndarray to simple deque of floats
                    self.slot_vehicles = deque(headways)
                    break
        # Return the time of arrival of the next vehicle
        next_vehicle_entrance_time = self.slot_vehicles.popleft()
        return next_vehicle_entrance_time

# Test code for the generator
if __name__ == '__main__':
    # Create a logger object
    panm_globals.LOGGER = logging.getLogger('vehiclegen')
    panm_globals.LOGGER.setLevel(logging.DEBUG)
    # Create console handler with a lower log level
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    # create formatters and add it to the handlers
    console_formatter = logging.Formatter('%(levelname)-8s %(message)s')
    console_handler.setFormatter(console_formatter)
    # add the handlers to logger
    panm_globals.LOGGER.addHandler(console_handler)
    # Create file handler which logs even debug messages
    local_log_file_handler = logging.FileHandler('vehiclegen.log', mode='w')
    local_log_file_handler.setLevel(logging.DEBUG)
    local_formatter = logging.Formatter(
        '%(asctime)s - [%(filename)s:%(lineno)4s - %(funcName)20s()] %(levelname)-8s %(message)s')
    local_log_file_handler.setFormatter(local_formatter)
    #
    panm_globals.LOGGER.addHandler(local_log_file_handler)

    panm_globals.LOGGER.info("logging started")

    vg = VehicleGenerator('0201/sokp-0201-20121001.mat')
    slot_length = 60.0
    slot_limit = slot_length
    slot_count = 0
    slot_idx = 0
    total_time = 0.0
    while total_time < 86400.0 and slot_idx < len(vg.data):
        total_time = vg.generate_next_vehicle(total_time)
        while slot_limit < total_time and slot_idx < len(vg.data):
            print('{:4.0f} {:2d} {:2d}'.format(slot_limit, slot_count, vg.data[slot_idx]))
            assert slot_count == vg.data[slot_idx]
            slot_limit += slot_length
            slot_count = 0
            slot_idx += 1
        slot_count += 1